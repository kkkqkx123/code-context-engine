# 函数调用关系处理

## 概述

本文档说明如何从AST中提取函数调用关系，并将其转换为三元组形式存储到图数据库中，作为代码语义理解的上下文补充。

## 核心目标

1. **提取调用关系**：从AST中识别函数调用语句
2. **构建三元组**：将调用关系转换为 `(调用者, 调用, 被调用者)` 格式
3. **存储到图数据库**：将三元组存入图数据库，支持关系查询
4. **补充上下文**：在自然语言转换时，补充调用关系信息

## 三元组设计

### 基本格式

```
(调用者函数, 调用, 被调用者函数)
```

### 扩展格式（包含上下文）

```
(调用者函数, 调用, 被调用者函数, 调用位置, 调用次数)
```

### 示例

```
(calculateTotalPrice, 调用, reduce)
(fetch_user_data, 调用, query)
(validateCredentials, 调用, ValidationResult.failure)
```

## AST提取逻辑

### 提取步骤

1. **遍历AST**：使用Tree-sitter遍历函数体节点
2. **识别调用节点**：查找函数调用表达式
3. **提取调用信息**：
   - 调用者函数名
   - 被调用者函数名
   - 调用位置（行号）
4. **构建三元组**：组装为标准格式

### 可操作性说明

所有提取逻辑都可以通过Tree-sitter的查询语法实现：

```typescript
// Tree-sitter查询示例
const query = `
  (function_definition
    name: (identifier) @caller
    body: (block
      (call_expression
        function: (identifier) @callee
      ) @call
    )
  )
`;
```

## 样例演示

### 样例1：JavaScript函数调用

#### 输入代码

```javascript
function calculateTotalPrice(items, discount) {
    const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    if (discount && discount > 0) {
        return subtotal * (1 - discount / 100);
    }
    return subtotal;
}
```

#### AST提取结果

| 调用者 | 被调用者 | 调用位置 |
|--------|----------|----------|
| `calculateTotalPrice` | `reduce` | 第2行 |
| `calculateTotalPrice` | `sum + item.price * item.quantity` | 第2行（回调函数） |

#### 三元组输出

```
(calculateTotalPrice, 调用, reduce)
(calculateTotalPrice, 调用, 匿名回调函数)
```

#### 自然语言补充

```
Function Calculate total price that does Calculate the total price of all items in the cart defined as function calculate total price items discount calls reduce calls anonymous callback function file cart js
```

---

### 样例2：Python函数调用

#### 输入代码

```python
def fetch_user_data(user_id, include_profile=False):
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise ValueError(f"User {user_id} not found")
    
    result = {
        'id': user.id,
        'name': user.name,
        'email': user.email
    }
    
    if include_profile:
        result['profile'] = user.profile
    
    return result
```

#### AST提取结果

| 调用者 | 被调用者 | 调用位置 |
|--------|----------|----------|
| `fetch_user_data` | `db.query` | 第2行 |
| `fetch_user_data` | `filter` | 第2行 |
| `fetch_user_data` | `first` | 第2行 |
| `fetch_user_data` | `ValueError` | 第4行 |

#### 三元组输出

```
(fetch_user_data, 调用, db.query)
(fetch_user_data, 调用, filter)
(fetch_user_data, 调用, first)
(fetch_user_data, 调用, ValueError)
```

#### 自然语言补充

```
Function Fetch user data that does Fetch user data from the database defined as def fetch user data user id include profile false calls db query calls filter calls first calls ValueError file user service
```

---

### 样例3：Rust函数调用

#### 输入代码

```rust
pub fn await_ready_for_timeout(&self, timeout: Duration) -> bool {
    let mut is_ready = self.value.lock();
    if !*is_ready {
        !self.condvar.wait_for(&mut is_ready, timeout).timed_out()
    } else {
        true
    }
}
```

#### AST提取结果

| 调用者 | 被调用者 | 调用位置 |
|--------|----------|----------|
| `await_ready_for_timeout` | `self.value.lock` | 第2行 |
| `await_ready_for_timeout` | `self.condvar.wait_for` | 第4行 |
| `await_ready_for_timeout` | `timed_out` | 第4行 |

#### 三元组输出

```
(await_ready_for_timeout, 调用, self.value.lock)
(await_ready_for_timeout, 调用, self.condvar.wait_for)
(await_ready_for_timeout, 调用, timed_out)
```

#### 自然语言补充

```
Function Await ready for timeout that does Return true if ready false if timed out defined as fn await ready for timeout self timeout duration bool calls self value lock calls self condvar wait for calls timed out defined in struct Is ready module common file is_ready
```

---

### 样例4：Java方法调用

#### 输入代码

```java
public ValidationResult validateCredentials(String username, String password) {
    if (username == null || password == null) {
        throw new IllegalArgumentException("Username and password cannot be null");
    }
    
    if (username.length() < 3) {
        return ValidationResult.failure("Username must be at least 3 characters");
    }
    
    if (password.length() < 8) {
        return ValidationResult.failure("Password must be at least 8 characters");
    }
    
    return ValidationResult.success();
}
```

#### AST提取结果

| 调用者 | 被调用者 | 调用位置 |
|--------|----------|----------|
| `validateCredentials` | `IllegalArgumentException` | 第3行 |
| `validateCredentials` | `username.length` | 第6行 |
| `validateCredentials` | `ValidationResult.failure` | 第7行 |
| `validateCredentials` | `password.length` | 第10行 |
| `validateCredentials` | `ValidationResult.failure` | 第11行 |
| `validateCredentials` | `ValidationResult.success` | 第14行 |

#### 三元组输出

```
(validateCredentials, 调用, IllegalArgumentException)
(validateCredentials, 调用, username.length)
(validateCredentials, 调用, ValidationResult.failure)
(validateCredentials, 调用, password.length)
(validateCredentials, 调用, ValidationResult.failure)
(validateCredentials, 调用, ValidationResult.success)
```

#### 自然语言补充

```
Function Validate credentials that does Validates the user input and returns validation result defined as public validation result validate credentials string username string password calls illegal argument exception calls username length calls validation result failure calls password length calls validation result failure calls validation result success of class auth service file auth service
```

---

### 样例5：C函数调用

#### 输入代码

```c
int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

#### AST提取结果

| 调用者 | 被调用者 | 调用位置 |
|--------|----------|----------|
| `gcd` | 无（无函数调用） | - |

#### 三元组输出

```
(gcd, 无调用, 无)
```

#### 自然语言补充

```
Function gcd that does Compute the greatest common divisor using Euclidean algorithm defined as int gcd int a int b file math utils
```

---

## 图数据库存储设计

### 节点类型

1. **函数节点**：表示一个函数
   - 属性：`name`, `signature`, `file_path`, `language`

2. **调用关系边**：表示函数调用关系
   - 属性：`call_count`, `call_locations`

### 存储示例

```cypher
// 创建函数节点
CREATE (f1:Function {name: 'calculateTotalPrice', file_path: 'cart.js', language: 'javascript'})
CREATE (f2:Function {name: 'reduce', file_path: 'array.js', language: 'javascript'})

// 创建调用关系
CREATE (f1)-[r:CALLS {call_count: 1, call_locations: ['line:2']}]->(f2)
```

### 查询示例

```cypher
// 查询某个函数调用的所有函数
MATCH (caller:Function {name: 'calculateTotalPrice'})-[:CALLS]->(callee:Function)
RETURN caller.name, callee.name

// 查询调用某个函数的所有函数
MATCH (caller:Function)-[:CALLS]->(callee:Function {name: 'reduce'})
RETURN caller.name, callee.name

// 查询调用链
MATCH path = (start:Function {name: 'fetch_user_data'})-[:CALLS*]->(end:Function)
RETURN path
```

## 自然语言转换中的调用关系补充

### 转换模板更新

```
Function {normalizedName} {docstringPart} defined as {normalizedSignature} calls {calledFunctions} {context}
```

### 处理逻辑

1. **提取调用关系**：从AST中提取函数调用列表
2. **规范化调用名**：将调用函数名转换为自然语言
3. **组装调用列表**：用空格连接所有调用函数
4. **补充到模板**：将调用列表添加到自然语言文本中

### 示例

#### 输入

```javascript
function calculateTotalPrice(items, discount) {
    const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
    if (discount && discount > 0) {
        return subtotal * (1 - discount / 100);
    }
    return subtotal;
}
```

#### 调用关系提取

```
调用函数列表：['reduce', '匿名回调函数']
```

#### 自然语言输出

```
Function Calculate total price that does Calculate the total price of all items in the cart defined as function calculate total price items discount calls reduce calls anonymous callback function file cart.js
```

## 复杂调用场景处理

### 1. 链式调用

#### 输入代码

```javascript
db.query(User).filter(User.id == user_id).first()
```

#### 处理方式

将链式调用拆分为多个三元组：

```
(fetch_user_data, 调用, db.query)
(fetch_user_data, 调用, filter)
(fetch_user_data, 调用, first)
```

### 2. 方法调用

#### 输入代码

```rust
self.value.lock()
```

#### 处理方式

保留接收者信息：

```
(await_ready_for_timeout, 调用, self.value.lock)
```

### 3. 回调函数

#### 输入代码

```javascript
items.reduce((sum, item) => sum + item.price * item.quantity, 0)
```

#### 处理方式

识别为匿名回调函数：

```
(calculateTotalPrice, 调用, reduce)
(calculateTotalPrice, 调用, 匿名回调函数)
```

### 4. 构造函数调用

#### 输入代码

```java
throw new IllegalArgumentException("Username and password cannot be null");
```

#### 处理方式

识别为构造函数调用：

```
(validateCredentials, 调用, IllegalArgumentException)
```

## 实现建议

### 1. 分阶段处理

```
阶段1：解析AST → 提取函数定义
阶段2：遍历函数体 → 提取函数调用
阶段3：构建三元组 → 存储到图数据库
阶段4：查询调用关系 → 补充到自然语言文本
```

### 2. 缓存策略

- 函数调用关系可以缓存，避免重复解析
- 使用文件哈希作为缓存键

### 3. 增量更新

- 监听文件变化，只更新修改文件的调用关系
- 删除已删除文件的调用关系

### 4. 错误处理

- 无法解析的调用关系记录日志，但不中断处理
- 使用回退方案：只记录函数名，不记录调用关系

## 可操作性验证

### Tree-sitter查询示例

```typescript
// JavaScript函数调用查询
const jsQuery = `
  (function_declaration
    name: (identifier) @caller
    body: (statement_block
      (expression_statement
        (call_expression
          function: (identifier) @callee
        )
      )
    )
  )
`;

// Python函数调用查询
const pythonQuery = `
  (function_definition
    name: (identifier) @caller
    body: (block
      (expression_statement
        (call
          function: (identifier) @callee
        )
      )
    )
  )
`;

// Rust函数调用查询
const rustQuery = `
  (function_item
    name: (identifier) @caller
    body: (block
      (expression_statement
        (call_expression
          function: (field_expression
            value: (identifier) @receiver
            field: (field_identifier) @callee
          )
        )
      )
    )
  )
`;
```

### 数据结构示例

```typescript
interface FunctionCall {
  caller: string;           // 调用者函数名
  callee: string;           // 被调用者函数名
  callLocation: string;     // 调用位置（文件:行号）
  callType: 'direct' | 'method' | 'constructor' | 'callback';
}

interface CallRelationship {
  source: string;           // 源函数ID
  target: string;           // 目标函数ID
  relationship: 'CALLS';    // 关系类型
  properties: {
    callCount: number;
    callLocations: string[];
  };
}
```

## 总结

### 核心优势

1. **可操作性强**：所有提取逻辑都可以通过Tree-sitter实现
2. **结构化存储**：三元组格式适合图数据库存储
3. **语义增强**：调用关系补充到自然语言文本，提高嵌入准确性
4. **关系查询**：支持复杂的调用链查询和分析

### 应用场景

1. **代码搜索**：通过调用关系扩展搜索范围
2. **依赖分析**：分析函数之间的依赖关系
3. **影响分析**：修改某个函数时，找出所有受影响的函数
4. **代码理解**：帮助开发者理解代码的调用流程

### 后续扩展

1. **调用频率统计**：记录函数调用次数，识别热点函数
2. **调用深度分析**：分析调用链的深度，识别复杂调用
3. **循环调用检测**：检测循环依赖，避免无限递归
4. **跨文件调用**：支持跨文件的调用关系分析