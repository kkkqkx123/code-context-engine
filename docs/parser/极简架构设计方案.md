# Parser模块极简架构设计方案

## 设计原则

1. **极简主义**：只保留核心功能，移除一切不必要的复杂性
2. **扁平结构**：取消深层目录结构，所有核心文件平铺
3. **直接调用**：取消工厂类、协调器等中介层，直接实例化和调用
4. **单一职责**：每个文件只负责一个明确的职责
5. **显式依赖**：依赖关系明确，不隐藏复杂性
6. **延迟设计**：不过早引入设计模式，根据实际需求后续添加

## 核心职责分析

Parser模块的核心职责只有三个：

1. **语言检测**：识别文件类型和编程语言
2. **代码解析**：将代码解析为AST（仅限支持的语言）
3. **代码分割**：将代码分割成适合向量嵌入的块

其他功能（如关系提取、复杂查询、多层缓存、后处理等）都是过度设计，应该移除。

## 新目录结构

```
src/service/parser/
├── index.ts                      # 统一导出
├── Parser.ts                     # 主解析类（入口）
├── LanguageDetector.ts           # 语言检测
├── ASTParser.ts                  # AST解析器
├── CodeSplitter.ts               # 代码分割器
├── types.ts                      # 类型定义
└── languages/                    # 语言相关数据
    ├── typescript.ts             # TypeScript查询模式
    ├── javascript.ts             # JavaScript查询模式
    ├── python.ts                 # Python查询模式
    └── ...                       # 其他语言
```

**结构说明**：
- 只有1层目录（languages子目录用于存放查询模式）
- 核心逻辑只有4个文件
- 总共不超过10个文件

## 核心模块职责

### 1. Parser.ts（主解析类）

**职责**：
- 接收文件路径和内容
- 调用LanguageDetector检测语言
- 根据文件类型决定处理流程
- 返回解析结果

**处理流程**：
1. 输入：文件路径和内容
2. 检测语言类型
3. 如果是代码文件（支持AST解析的语言）：
   - 调用ASTParser解析为AST
   - 调用CodeSplitter进行智能分割
   - 返回AST和代码块
4. 如果是文本文件：
   - 调用CodeSplitter进行简单分割
   - 返回代码块
5. 输出：解析结果（包含语言、AST（可选）、代码块）

**依赖**：
- LanguageDetector
- ASTParser
- CodeSplitter

**设计要点**：
- 直接实例化依赖类，不通过工厂
- 简单的错误处理（try-catch，失败返回空结果）
- 无缓存（缓存由上层服务决定）

### 2. LanguageDetector.ts（语言检测）

**职责**：
- 根据文件扩展名判断语言
- 返回语言名称和文件类型

**实现逻辑**：
- 维护一个扩展名到语言的映射表
- 根据文件扩展名查找语言
- 特殊文件（如Dockerfile、Makefile）特殊处理

**输入**：文件路径
**输出**：语言名称（如typescript、python、markdown等）

**设计要点**：
- 纯函数实现，无状态
- 同步操作，无需异步
- 简单映射，不分析文件内容

### 3. ASTParser.ts（AST解析器）

**职责**：
- 使用Tree-sitter解析代码为AST
- 提取代码结构（函数、类等）

**实现逻辑**：
- 动态加载Tree-sitter语言解析器
- 解析代码生成AST
- 使用Tree-sitter查询提取代码结构
- 返回AST和代码结构信息

**输入**：代码内容、语言名称
**输出**：AST节点、代码结构（函数列表、类列表等）

**设计要点**：
- 按需加载语言解析器（动态import）
- 查询模式从languages目录加载
- 简单的错误处理（解析失败返回null）
- 无缓存（由调用者决定是否需要缓存）

### 4. CodeSplitter.ts（代码分割器）

**职责**：
- 将代码分割成适合向量嵌入的块
- 支持代码文件和文本文件

**实现逻辑**：
- 代码文件：基于AST结构进行语义分割
  - 按函数、类、方法等边界分割
  - 保证每个块语法完整
  - 块大小可配置
- 文本文件：基于简单规则分割
  - 按段落、标题等分割
  - 块大小可配置

**输入**：代码内容、语言名称、AST（可选）
**输出**：代码块数组（每个块包含内容、行号、类型等）

**设计要点**：
- 如果是代码文件且有AST，使用语义分割
- 否则使用文本分割
- 简单的块大小控制（字符数或行数）
- 无复杂后处理

## 类型定义

### 核心类型

```typescript
// 解析结果
interface ParseResult {
  language: string;              // 语言名称
  ast?: any;                     // AST（代码文件有）
  chunks: CodeChunk[];           // 代码块
  success: boolean;              // 是否成功
  error?: string;                // 错误信息（如果有）
}

// 代码块
interface CodeChunk {
  content: string;               // 块内容
  startLine: number;             // 起始行
  endLine: number;               // 结束行
  type: string;                  // 块类型（function、class、text等）
  metadata?: Record<string, any>; // 额外元数据
}

// 代码结构
interface CodeStructure {
  functions: FunctionInfo[];     // 函数列表
  classes: ClassInfo[];          // 类列表
  imports: ImportInfo[];         // 导入列表
  // ... 其他结构
}
```

### 简单类型，无泛型

- 不使用复杂的泛型类型
- 不使用类型体操
- 保持类型定义简单明了

## 查询模式管理

### languages目录结构

```
languages/
├── typescript.ts     # TypeScript查询模式
├── javascript.ts     # JavaScript查询模式
├── python.ts         # Python查询模式
├── go.ts             # Go查询模式
├── rust.ts           # Rust查询模式
└── ...               # 其他语言
```

### 查询模式格式

每个文件导出一个对象，包含该语言的查询模式：

```typescript
export const queries = {
  // 函数查询
  functions: `
    (function_declaration
      name: (identifier) @name
      body: (block) @body) @function
  `,
  
  // 类查询
  classes: `
    (class_declaration
      name: (identifier) @name
      body: (class_body) @body) @class
  `,
  
  // 导入查询
  imports: `
    (import_statement) @import
  `
};
```

**设计要点**：
- 每个语言一个文件
- 简单的对象结构
- 查询模式使用Tree-sitter语法
- 按需加载（动态import）

## 工作流程

### 代码文件处理流程

1. **输入**：文件路径和代码内容
2. **语言检测**：LanguageDetector根据扩展名识别语言
3. **AST解析**：ASTParser解析代码为AST
4. **结构提取**：使用Tree-sitter查询提取函数、类等结构
5. **代码分割**：CodeSplitter基于AST结构进行语义分割
6. **输出**：返回ParseResult（包含AST和代码块）

### 文本文件处理流程

1. **输入**：文件路径和内容
2. **语言检测**：识别为文本类型（如markdown、txt等）
3. **代码分割**：CodeSplitter使用简单规则分割文本
4. **输出**：返回ParseResult（只有代码块，无AST）

### 错误处理流程

1. **任何步骤失败**：捕获错误，记录日志
2. **返回部分结果**：已完成的步骤结果返回
3. **错误信息**：在ParseResult中记录错误信息
4. **不阻塞流程**：失败时返回success: false，但程序不崩溃

## 配置管理

### 极简配置

```typescript
interface ParserConfig {
  // 块大小限制
  chunkSize: {
    min: number;        // 最小块大小（字符数）
    max: number;        // 最大块大小（字符数）
  };
  
  // 支持的语言
  supportedLanguages: string[];
  
  // Tree-sitter选项
  treeSitter: {
    timeout: number;    // 解析超时时间（毫秒）
  };
}
```

**设计要点**：
- 配置项不超过10个
- 有合理的默认值
- 支持环境变量覆盖
- 不需要配置文件，代码中配置即可

## 错误处理

### 简单错误处理策略

1. **同步错误**：直接抛出，调用者处理
2. **异步错误**：Promise reject，调用者catch
3. **解析错误**：返回null或空数组，不抛出
4. **日志记录**：简单的console.warn/error，不引入复杂日志系统

### 错误类型

- `ParseError`：解析失败
- `LanguageNotSupportedError`：语言不支持
- `TimeoutError`：操作超时

**设计要点**：
- 错误类型简单明了
- 不创建复杂的错误类层次结构
- 错误信息清晰易懂

## 性能考虑

### 无缓存设计

- 不内置缓存机制
- 由上层服务决定是否需要缓存
- 保持Parser无状态

### 按需加载

- Tree-sitter语言解析器动态加载
- 查询模式动态加载
- 减少内存占用

### 简单并行

- 不内置复杂并行机制
- 由调用者决定是否需要并行
- 保持代码简单

## 测试策略

### 测试文件位置

```
src/service/parser/
├── __tests__/
│   ├── Parser.test.ts              # 主解析类测试
│   ├── LanguageDetector.test.ts    # 语言检测测试
│   ├── ASTParser.test.ts           # AST解析器测试
│   └── CodeSplitter.test.ts        # 代码分割器测试
```

### 测试数据

```
test-files/
├── parser/
│   ├── typescript/
│   │   ├── simple.ts               # 简单TypeScript文件
│   │   ├── complex.ts              # 复杂TypeScript文件
│   │   └── expected.json           # 期望结果
│   ├── python/
│   │   ├── simple.py               # 简单Python文件
│   │   └── complex.py              # 复杂Python文件
│   └── markdown/
│       ├── simple.md               # 简单Markdown文件
│       └── complex.md              # 复杂Markdown文件
```

### 测试类型

1. **单元测试**：每个类的公共方法
2. **集成测试**：完整解析流程
3. **边界测试**：空文件、大文件、特殊字符等
4. **性能测试**：大文件解析性能

## 依赖管理

### 外部依赖

```json
{
  "dependencies": {
    "tree-sitter": "^0.20.0",           // Tree-sitter核心
    "tree-sitter-typescript": "^0.20.0",  // TypeScript解析器
    "tree-sitter-python": "^0.20.0",      // Python解析器
    // ... 其他语言解析器按需添加
  }
}
```

**设计要点**：
- 只依赖必要的Tree-sitter包
- 语言解析器按需安装
- 不引入其他复杂依赖

### 内部依赖

- Parser依赖LanguageDetector、ASTParser、CodeSplitter
- ASTParser依赖languages目录下的查询模式
- 无循环依赖
- 依赖关系简单清晰

## 使用示例

### 基本使用

```typescript
import { Parser } from './service/parser';

// 创建解析器实例
const parser = new Parser();

// 解析代码文件
const result = await parser.parseFile('example.ts', codeContent);

if (result.success) {
  console.log('语言:', result.language);
  console.log('代码块数量:', result.chunks.length);
  
  if (result.ast) {
    console.log('AST已生成');
  }
} else {
  console.error('解析失败:', result.error);
}
```

### 错误处理

```typescript
try {
  const result = await parser.parseFile('example.ts', codeContent);
  
  if (!result.success) {
    console.warn('解析完成但有错误:', result.error);
  }
  
  // 使用部分结果
  console.log('成功获取', result.chunks.length, '个代码块');
} catch (error) {
  console.error('解析失败:', error);
}
```

## 未来扩展点

### 可能的扩展（但不现在实现）

1. **插件系统**：支持自定义解析器
2. **缓存层**：内置缓存机制
3. **并行处理**：自动并行化
4. **流式处理**：支持大文件流式解析
5. **增量解析**：只解析变更部分

**设计要点**：
- 现在不考虑这些扩展
- 保持代码简单
- 后续根据实际需求添加
- 不预留过度抽象的扩展点

## 与现有系统的对比

### 文件数量
- 现有：200+个文件
- 新设计：~10个文件
- 减少：95%

### 代码行数
- 现有：~20,000行
- 新设计：~1,500-2,000行
- 减少：90%

### 复杂度
- 现有：6种策略、6种后处理器、多层缓存、复杂协调器
- 新设计：2种分割方式、无后处理、无缓存、直接调用
- 简化：85%

### 维护成本
- 现有：高（理解困难、修改风险大）
- 新设计：低（简单明了、易于修改）
- 降低：80%

## 总结

这个极简设计方案：

1. **移除了所有过度设计的部分**：协调器、工厂类、策略系统、后处理系统、保护机制等
2. **保留了核心功能**：语言检测、AST解析、代码分割
3. **简化了架构**：从200+文件减少到~10个文件
4. **明确了职责**：每个类职责单一且清晰
5. **降低了复杂度**：代码量减少90%
6. **保持了扩展性**：后续可以根据需要添加设计模式

这个设计足够简单，易于理解和维护，同时满足了Parser模块的核心需求。